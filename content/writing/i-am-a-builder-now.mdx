---
title: "I Am a Builder Now"
slug: "i-am-a-builder-now"
date: "2025-09-15"
description: "Software engineering is where ideas become real or quietly die. I have been shifting from data scientist to builder, and agentic engineering is part of how."
tags:
  - Agentic engineering
  - Software engineering
  - AI
---

Lately I have been noticing a shift in how I talk about my work. I still care about data and modeling, but I spend more of my energy on building systems that have to run, survive real inputs, and hold up under scrutiny.

For a long time I described myself as a data scientist who happened to write code. That description was not false. It also gave me an easy escape hatch. I could stay in notebooks and analysis and let someone else worry about integration, environments, deployment, reliability, and security.

Then work kept pulling me toward those details anyway.

The honest truth is that software engineering is where ideas either become real or quietly die. It is where assumptions meet logs, timeouts, permissions, dependency conflicts, and all the boring things that suddenly matter a lot.

Debugging by searching the internet used to frustrate me more than it should have. I wanted an answer immediately. I wanted a mentor sitting next to me. In graduate school I had that. In professional life you are expected to already be the professional, and the mentoring is scattered across documentation, old threads, and whoever has a few minutes.

Then I started debugging with a chatbot.

It did not feel like cheating. It felt like getting the conversation back into the work. I could paste an error and ask for the next diagnostic step. I could ask for an explanation in plain language. I could ask what I might be missing. The model was not always right, but it kept me moving and it lowered the friction of staying engaged.

Some people dismiss that as shallow. I get why. Still, if you have ever lost an hour to a tiny environment issue, you know what it means to regain momentum without lowering standards.

This is also where I want to be specific about what I mean when I say agentic engineering.

I am not talking about copying code from an assistant and trusting it blindly. I am talking about working with a system that can propose a plan, draft code, help write tests, refactor, and iterate with me in tight loops.

Simon Willison has written about the risk here in a way that resonates with me. These tools can produce output that looks polished and still hides subtle mistakes. The code can be persuasive even when the reasoning is weak. If you treat that output as truth, you will eventually pay for it.

Andrej Karpathy helped popularize the idea that you can keep flow with an assistant that fills in gaps. That experience is real. You can move faster. The question is what you do with that speed.

For me, the builder skill is not speed by itself. The builder skill is keeping the work honest while speed increases.

When I collaborate with an agent, my job is framing and verification. I define success in concrete terms. I constrain the scope. I ask for tests. I run the code. I read the logs. I check edge cases. I tighten interfaces. I reduce ambiguity until the system cannot drift into a story that only sounds right.

I have also become more operational about how I start projects.

I get something running quickly, even if the first version is thin. I want a local environment that boots. I want a dev server that responds. I want a small slice end to end that I can validate. Once it runs, I can iterate and keep learning. If it does not run, it is too easy to debate abstractions instead of shipping reality.

I reset agent conversations more often than I used to. When the assistant starts drifting, repeating itself, or inventing details, I do not try to rescue the thread with more and more context. I start a new thread with a cleaner frame and a smaller task. I treat it like steering a meeting back to the agenda.

There is also a leadership angle hiding in all of this.

Agentic engineering makes it easier to produce code, which means it becomes easier to produce complexity. Teams that already have strong feedback loops will likely use agents to shorten cycles, tighten tests, and move faster with control. Teams without those habits might simply generate more surface area than they can understand.

That is why I keep coming back to roles and incentives. People still own systems. People still sign their names to decisions. Agents can help draft and explore, but they cannot be accountable for consequences.

My current working thesis is simple. Agentic engineering is here. The builder advantage will belong to people and teams who pair that leverage with discipline.

If you are building with agents already, I would genuinely like to hear what has worked for you. What practices help you move fast while staying grounded in quality and security.
